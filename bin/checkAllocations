eval '(exit $?0)' && 
    eval 'exec perl -S $0 ${1+"$@"}' && 
    eval 'exec perl -S $0 $argv:q'
    if 0;

#############################################################################
#  Validity Checker for the Isolation (isol.log)
#
#  Copyright (C) 2014 TO THE AUTHORS
#
# to the blind review this software is available for SigComm evaluation 
# only. Once accepted it will be published with chioce of GPLv2 and BSD
# licenses.  
# You are not allowed to copy or publish this software in any way.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#
# Given:
# n,r,m and an isolation allocation log 
# Check: that no conflicts exist
#
#############################################################################

=head1 TITLE

checkAllocations - check job isolation allocation correctness on 3 level XGFT fat-tree

=head1 SYNOPSIS

checkAllocations -n/--hosts-per-leaf n -k/--num-l1-per-l2 -1/--total-l1s r -2/--total-l2s -3/--total-l3s -l/--log log-file 

=head1 DESCRIPTION

Validate a log file of ADD and REM generated by the isolation algorithm

=head1 ARGUMENTS

=over 8

=item B<--hosts-per-leaf|-n n>

Number of hosts on each leaf

=item B<--num-l1-per-l2|-k num>

Num of L1 switches connected to each L2

=item B<--total-l1s|-1 num>

Num of L1 switches in entire cluster

=item B<--total-l2s|-2 num>

Num of L2 switches in entire cluster

=item B<--total-l3s|-3 num>

Num of L3 switches in entire cluster

=item B<--log|-l log-file>

Isolation Placement log file

=back

=head1 OPTIONS

=over 8

=item B<--verbose|-v>

Run in verbose mode

=item B<--help|-h>

Print a brief help message and exits.

=item B<--man|-m>

Print a detailed help message (man) and exits.

=back

=head1 LICENSE

 Due to the blind review this software is available for SigComm evaluation 
 only. Once accepted it will be published with chioce of GPLv2 and BSD
 licenses.  
 You are not allowed to copy or publish this software in any way.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

=head1 Revision

$Revision$

=head1 AUTHOR

Copyright (C) 2014 TO THE AUTHORS

=cut

#############################################################################
#
# Commands line parsing
# 

use vars qw($VERSION);

# use RCS info as we reposit in RCS
($VERSION) = ('$Revision$' =~ m/(.*)/);

use strict;
use warnings;
use diagnostics;
use Getopt::Long;
use Pod::Usage;
use Math::Random qw(random_normal random_uniform random_exponential);
use Math::Round;
use List::Util qw(shuffle);

my $opt_verbose = 0;
my ($opt_help, $opt_man);
my $opt_n;
my $opt_1;
my $opt_2;
my $opt_3;
my $opt_l;
my $opt_k;

my $cmd = join(" ", @ARGV);

GetOptions(
    'n|hosts-per-leaf=s'  => \$opt_n,
    'k|num-l1-per-l2=s'   => \$opt_k,
    '1|total-l1s=s'       => \$opt_1,
    '2|total-l2s=s'       => \$opt_2,
    '3|total-l3s=s'       => \$opt_3,
    'l|log=s'             => \$opt_l,
    'v|verbose'     => \$opt_verbose,
    'h|help'        => \$opt_help,
    'm|man'         => \$opt_man,
    ) or pod2usage(-verbose => 1) && exit;

pod2usage(-verbose => 1) && exit if defined $opt_help;
pod2usage(-verbose => 2) && exit if defined $opt_man;

# Replace the below with a check for mandatory arguments
pod2usage("$0: Missing mandatory arguments.") && exit
    if (! (defined($opt_n) && defined($opt_1) && defined($opt_2)
           && defined($opt_3) && defined($opt_l) && defined($opt_k) ));

#############################################################################
#
# DB
#
my %LEAF_ALLOC_HOSTS;
my %L2_PORTS;
my %L3_PORTS;
my %JOB_HOSTS;
my %JOB_L2PORTS;
my %JOB_L3PORTS;

#############################################################################
#
# Subroutines
# 
sub analyzeContentionRules($$$$$$$$$$) {
    my ($J, $A,$B,$C,$D,$R,$S,$Q, $l1STs, $l2STs) = @_;
    
    # find the V sub tree if exists
    my $U = $R*$A+$B;
    my $V = $S*$C+$D;

    my $fU = 0;
    my $fV = 0;
    
    my $anyErr = 0;

    my %ST_TYPE;
    my %FA;
    my %FB;
    my %FC;
    my %FD;

    # first step is to find the 2 max sized values
    for (my $i = 0; $i < scalar(@{$l2STs}); $i++) {
        my $hosts = ${$l2STs}[$i];
        if (!defined($hosts) || ($hosts == 0)) {
            next;
        }
        if ($hosts == $U) {
            $fU++;
            $ST_TYPE{$i} = "U";
            print "-V- L2 $i is marked U type\n" if $opt_verbose;
            $FA{$i} = 0;
            $FB{$i} = 0;
        } elsif ($hosts == $V) {
            if ($fV == 0) {
                $fV++;
                $ST_TYPE{$i} = "V";
                print "-V- L2 $i is marked V type\n" if $opt_verbose;
                $FC{$i} = 0;
                $FD{$i} = 0;
            } else {
                print "-E- Job $J L2 sub-tree $i has V=$V hosts but a sub-tree of that number already found !!!\n";
                $anyErr++;
            }
        }
    }
    if ($fU != $Q) {
        print "-E- Job $J Expected Q=$Q but got $fU instead\n";
        $anyErr = 1;
    }

    # Now treat each L1 
    for (my $i = 0; $i < scalar(@{$l1STs}); $i++) {
        my $hosts = ${$l1STs}[$i];
        if (!defined($hosts) || ($hosts == 0)) {
            next;
        }
        
        my $l2st = int($i / $opt_k);
        my $stType = $ST_TYPE{$l2st};
        if (!defined($stType)) {
            print "-E- Job $J L1 $i has $hosts hosts under L2 $l2st which has no U or V types !!!\n";
            $anyErr++;
        } elsif ($stType eq "U") {
            if ($hosts == $A) {
                $FA{$l2st}++;
                print "-V- L1 $i in L2 $l2st is marked A type\n" if $opt_verbose;
            } elsif ($hosts == $B) {
                $FB{$l2st}++;
                print "-V- L1 $i in L2 $l2st is marked B type\n" if $opt_verbose;
            } else {
                print "-E- Job $J L1 $i has $hosts hosts under L2 $l2st but A=$A or B=$B\n";
                $anyErr++;
            }
        } elsif ($stType eq "V") {
            if ($hosts == $C) {
                $FC{$l2st}++;
            } elsif ($hosts == $D) {
                $FD{$l2st}++;
            } else {
                print "-E- Job $J L1 $i has $hosts hosts under L2 $l2st but C=$C or D=$D\n";
                $anyErr++;
            }
        } else {
            print "-E- Job $J L1 $i has $hosts hosts under L2 $l2st which has unknown type: $stType\n";
            $anyErr++;
        }
    } # all L1s

    # no check all L2 sub trees
    foreach my $l2st (keys(%ST_TYPE)) {
        my $type = $ST_TYPE{$l2st};
        if ($type eq "U") {
            if ($FA{$l2st} != $R) {
                print "-E- Job $J L2 $l2st has $FA{$l2st} A L1s != R = $R\n";
                $anyErr++;                
            }
            if ($FB{$l2st} > 1) {
                print "-E- Job $J L2 $l2st has $FB{$l2st} B L1s > 1\n";
                $anyErr++;                
            }
        } elsif ($type eq "V") {
            if ($FC{$l2st} != $S) {
                print "-E- Job $J L2 $l2st has $FC{$l2st} C L1s != S = $S\n";
                $anyErr++; 
            }
            if ($FD{$l2st} > 1) {
                print "-E- Job $J L2 $l2st has $FD{$l2st} D L1s > 1\n";
                $anyErr++;                
            }
        }
    }
    return $anyErr;
}

sub parseLogFile($) {
    my $fileName = shift;
    
    if (!open(F, "<$fileName")) {
        print STDERR "-E- Cant read $fileName\n";
        exit(1);
    }
    my $anyErr = 0;
    my $lineNum = 0;
    my $nJobsAdd = 0;
    my $nJobsRem = 0;
    my $addedL2Ports = 0;
    my $remL2Ports = 0;
    my $addedL3Ports = 0;
    my $remL3Ports = 0;
    my $totLinks = 0;
    while (my $line = <F>) {
        $lineNum++;
        if ($line =~ m/(ADD|REM)/) { 
            my $jobAddL2Ports = 0;
            my $jobAddL3Ports = 0;
            my ($A,$B,$C,$D,$R,$S,$Q);
            if ($line =~ m/(ADD|REM) Job:([0-9]+) hosts:([0-9]+)( links:([0-9]+))?( A=([0-9]+) B=([0-9]+) C=([0-9]+) D=([0-9]+) R=([0-9]+) S=([0-9]+) Q=([0-9]+) )?LEAFS ([0-9\s:]*)( L1PORTS ([0-9\s:]*))?( L2PORTS ([0-9\s:]*))?\s*$/) {
                my ($op, $job, $totHosts,$totLinks,$SETS,$A, $B, $C, $D, $R, $S, $Q, $l1Hosts, $l2Ports, $l3Ports) = 
                    ($1,$2,$3,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$16,$18);
                
                if ($op eq "ADD") {
                    $nJobsAdd++;
                } else {
                    $nJobsRem++;
                }
                # for now we treat the resources as opaque
                my $acumHosts = 0;
                my @L2_JOB_SUB_TREE_HOSTS;
                my @L1_JOB_SUB_TREE_HOSTS;
                while ($l1Hosts =~ m/([0-9]+):([0-9]+)/g) {
                    my ($leaf, $hosts) = ($1,$2);
                    if ($leaf > $opt_1) {
                        print "-E- Job $job Leaf $leaf > max-leaf=$opt_1\n"; 
                        $anyErr++;
                    }
                    if ($op eq "ADD") {
                        if (!defined($LEAF_ALLOC_HOSTS{$leaf})) {
                            $LEAF_ALLOC_HOSTS{$leaf} = 0;
                        }
                        $L1_JOB_SUB_TREE_HOSTS[$leaf] = $hosts;
                        
                        if ($LEAF_ALLOC_HOSTS{$leaf} + $hosts > $opt_n) {
                            print "-E- Job $job overuse Leaf $leaf : prev=$LEAF_ALLOC_HOSTS{$leaf} + new=$hosts > $opt_n\n"; 
                            $anyErr++;
                        } else {
                            $acumHosts += $hosts;
                            $LEAF_ALLOC_HOSTS{$leaf} += $hosts;
                        }
                        my $l2SubTree = int($leaf / $opt_k);
                        if (!defined($L2_JOB_SUB_TREE_HOSTS[$l2SubTree])) {
                            $L2_JOB_SUB_TREE_HOSTS[$l2SubTree] = $hosts;
                        } else {
                            $L2_JOB_SUB_TREE_HOSTS[$l2SubTree] += $hosts;
                        }
                    } else {
                        if (!defined($LEAF_ALLOC_HOSTS{$leaf})) {
                            print "-E- Job $job remove Leaf $leaf hosts $hosts not previously already defined\n";
                            $anyErr++;
                        } else {
                            if ($LEAF_ALLOC_HOSTS{$leaf} - $hosts < 0) {
                                print "-E- Job $job remove Leaf $leaf Hosts $hosts while record is: $LEAF_ALLOC_HOSTS{$leaf}\n";
                                $LEAF_ALLOC_HOSTS{$leaf} -= $LEAF_ALLOC_HOSTS{$leaf};
                                $anyErr++;
                            } else {
                                $acumHosts += $hosts;
                                $LEAF_ALLOC_HOSTS{$leaf} -= $hosts;
                            }
                        }
                    }
                } # all leafs
                if (($op eq "ADD") && defined($SETS)) {
                    analyzeContentionRules($job, $A,$B,$C,$D,$R,$S,$Q,\@L1_JOB_SUB_TREE_HOSTS, \@L2_JOB_SUB_TREE_HOSTS);
                }

                if ($acumHosts < $totHosts) {
                    print "-E- Job $job total hosts $totHosts > $acumHosts accumulated hosts on all leafs\n";
                    $anyErr++;
                }
                if (defined($l2Ports)) {
                    while ($l2Ports =~ m/([0-9]+:[0-9]+)/g) {
                        my $swPort = $1;
                        if ($op eq "ADD") {
                            if (defined($L2_PORTS{$swPort})) {
                                print "-E- Job $job overuse L2:Port $swPort already defined for job: $L2_PORTS{$swPort}\n";
                                $anyErr++;
                            } else {
                                $L2_PORTS{$swPort} = $job;
                                $addedL2Ports++;
                                $jobAddL2Ports++;
                                push @{$JOB_L2PORTS{$job}}, $swPort;
                            }
                        } else {
                            if (!defined($L2_PORTS{$swPort})) {
                                print "-E- Job $job remove L2:Port $swPort not previously defined\n";
                                $anyErr++;
                            } else {
                                undef $L2_PORTS{$swPort};
                                $remL2Ports++;
                            } 
                        }
                    }
                } else {
                    # cleanup 
                    if ($op eq "REM") {
                        if (defined($JOB_L2PORTS{$job})) {
                            for (my $k = 0; $k < scalar(@{$JOB_L2PORTS{$job}}); $k++) {
                                my $swPort = ${$JOB_L2PORTS{$job}}[$k];
                                undef $L2_PORTS{$swPort};
                                $remL2Ports++;
                            }
                        }
                    }
                }
                if (defined($l3Ports)) {
                    while ($l3Ports =~ m/([0-9]+:[0-9]+)/g) {
                        my $swPort = $1;
                        if ($op eq "ADD") {
                            if (defined($L3_PORTS{$swPort})) {
                                print "-E- Job $job overuse L3:Port $swPort already defined for job: $L3_PORTS{$swPort}\n";
                                $anyErr++;
                            } else {
                                $L3_PORTS{$swPort} = $job;
                                $addedL3Ports++;
                                $jobAddL3Ports++;
                                push @{$JOB_L3PORTS{$job}}, $swPort;
                            }
                        } else {
                            if (!defined($L3_PORTS{$swPort})) {
                                print "-E- Job $job remove L3:Port $swPort not previously defined\n";
                                $anyErr++;
                            } else {
                                undef $L3_PORTS{$swPort};
                                $remL3Ports++;
                            } 
                        }
                    }
                } else {
                    # cleanup 
                    if ($op eq "REM") {
                        if (defined($JOB_L3PORTS{$job})) {
                            for (my $k = 0; $k < scalar(@{$JOB_L3PORTS{$job}}); $k++) {
                                my $swPort = ${$JOB_L3PORTS{$job}}[$k];
                                undef $L3_PORTS{$swPort};
                                $remL3Ports++;
                            }
                        }
                    }
                }

                if ($op eq "ADD") {
                    my $nL = $acumHosts + $jobAddL2Ports + 18*$jobAddL3Ports;
                    if ($nL != $totLinks) {
                        # HACK hardcoded W2 = 18 
                        print STDERR "-E- Job $job total links: $totLinks != $nL = H:$acumHosts + L1Up:$jobAddL2Ports + L2Up:18*$jobAddL3Ports\n";
                        $anyErr++;
                    }
                }
            } else {
                print STDERR "-E- Unparsible line in $lineNum\n";
                $anyErr++;
            }
        }
    }
    close(F);
    print "-I- Checked $nJobsAdd ADD and $nJobsRem REM jobs\n";
    print "-I- Added/Rem $addedL2Ports/$remL2Ports L1PORTS and $addedL3Ports/$remL3Ports L2PORTS\n";
    return $anyErr;
}

#############################################################################
#
# Main Flow
# 

my $anyErr = parseLogFile($opt_l);
exit($anyErr);

